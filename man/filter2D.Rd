% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter2D.R, R/filter2D_all.R
\name{filter2D}
\alias{filter2D}
\alias{filter2D,GPRvirtual-method}
\alias{filter2D,GPRslice-method}
\alias{filter2D,GPRcube-method}
\alias{filter2Dmedian3x3}
\alias{filter2Dadimpro}
\alias{filter2Dgaussian}
\alias{filter2Disoblur}
\alias{filter2Dmedianblur}
\alias{filter2Danisotropic}
\alias{filter2Ddiffusiontensors}
\alias{filter2Dgradient}
\alias{filter2Dfftlowpass}
\alias{filter2Dmedian3x3,GPRvirtual-method}
\alias{filter2Dadimpro,GPRvirtual-method}
\alias{filter2Dgaussian,GPRvirtual-method}
\alias{filter2Disoblur,GPRvirtual-method}
\alias{filter2Dmedianblur,GPRvirtual-method}
\alias{filter2Danisotropic,GPRvirtual-method}
\alias{filter2Ddiffusiontensors,GPRvirtual-method}
\alias{filter2Dgradient,GPRvirtual-method}
\alias{filter2Dfftlowpass,GPRvirtual-method}
\alias{filter2Dblur_anisotropic}
\alias{filter2DcannyEdges}
\alias{filter2Dimhessian}
\alias{filter2Dimlap}
\alias{filter2Dimsharpen}
\alias{filter2DlocalContrast}
\alias{filter2DsmoothSparse}
\title{Two-dimensional filters}
\usage{
filter2D(obj, type = c("median3x3", "adimpro", "gaussian"), ..., track = TRUE)

\S4method{filter2D}{GPRvirtual}(obj, type = c("median3x3", "adimpro", "gaussian"), ..., track = TRUE)

\S4method{filter2D}{GPRslice}(obj, type = c("median3x3", "adimpro", "gaussian"), ..., track = TRUE)

\S4method{filter2D}{GPRcube}(obj, type = c("median3x3", "adimpro", "gaussian"), ..., track = TRUE)

filter2Dmedian3x3(obj, ..., track = TRUE)

\S4method{filter2Dmedian3x3}{GPRvirtual}(obj, ..., track = TRUE)

filter2Dadimpro(obj, ..., track = TRUE)

\S4method{filter2Dadimpro}{GPRvirtual}(obj, ..., track = TRUE)

filter2Dgaussian(obj, ..., track = TRUE)

\S4method{filter2Dgaussian}{GPRvirtual}(obj, ..., track = TRUE)

filter2Disoblur(obj, sigma = 1, ..., track = TRUE)

\S4method{filter2Disoblur}{GPRvirtual}(obj, sigma = 1, ..., track = TRUE)

filter2Dmedianblur(obj, n = 3, threshold = 0, ..., track = TRUE)

\S4method{filter2Dmedianblur}{GPRvirtual}(obj, n = 3, threshold = 0, ..., track = TRUE)

filter2Danisotropic(
  obj,
  amplitude = 1,
  sharpness = 0.7,
  anisotropy = 0.6,
  alpha = 0.6,
  sigma = 1.1,
  dl = 0.8,
  da = 30,
  ...,
  track = TRUE
)

\S4method{filter2Danisotropic}{GPRvirtual}(
  obj,
  amplitude = 1,
  sharpness = 0.7,
  anisotropy = 0.6,
  alpha = 0.6,
  sigma = 1.1,
  dl = 0.8,
  da = 30,
  ...,
  track = TRUE
)

filter2Ddiffusiontensors(
  obj,
  sharpness = 0.7,
  anisotropy = 0.6,
  alpha = 0.6,
  sigma = 1.1,
  ...,
  track = TRUE
)

\S4method{filter2Ddiffusiontensors}{GPRvirtual}(
  obj,
  sharpness = 0.7,
  anisotropy = 0.6,
  alpha = 0.6,
  sigma = 1.1,
  ...,
  track = TRUE
)

filter2Dgradient(obj, type = c("xy", "x", "y"), ..., track = TRUE)

\S4method{filter2Dgradient}{GPRvirtual}(obj, type = c("xy", "x", "y"), ..., track = TRUE)

filter2Dfftlowpass(obj, cutoff = 0.04, strength = 0.85, ..., track = TRUE)

\S4method{filter2Dfftlowpass}{GPRvirtual}(obj, cutoff = 0.04, strength = 0.85, ..., track = TRUE)

filter2Dblur_anisotropic(
  obj,
  amplitude = 1,
  sharpness = 0.7,
  anisotropy = 0.6,
  alpha = 0.6,
  sigma = 1.1,
  dl = 0.8,
  da = 30,
  ...,
  track = TRUE
)

filter2DcannyEdges(obj, sigma = 1, alpha = 0.5, ..., track = TRUE)

filter2Dimhessian(obj, sigma = 1, ..., track = TRUE)

filter2Dimlap(obj, ..., track = TRUE)

filter2Dimsharpen(
  obj,
  amplitude = 1,
  type = "diffusion",
  edge = 1,
  alpha = 0,
  sigma = 0,
  ...,
  track = TRUE
)

filter2DlocalContrast(
  obj,
  win = 3,
  alpha = 0,
  epsilon = 1e-08,
  ...,
  track = TRUE
)

filter2DsmoothSparse(obj, scale = 0.05, power = 1.5, ..., track = TRUE)
}
\arguments{
\item{obj}{(\code{GPR* object}) Object inheriting from \code{GPRvirtual}.}

\item{type}{(\code{character[1]}) Filter method.}

\item{...}{Additional arguments passed to \pkg{imager}::imsharpen.}

\item{track}{(\code{logical(1)}), default TRUE.}

\item{sigma}{numeric, default 1. Gaussian smoothing before computing Hessian.}

\item{n}{odd integer kernel size (default 3)}

\item{amplitude}{numeric, default 1. Controls intensity of blur.}

\item{sharpness}{numeric, default 0.7. Controls edge sharpness preservation.}

\item{anisotropy}{numeric, default 0.6. Controls anisotropy of smoothing.}

\item{alpha}{numeric, default 0.5. Threshold blending factor.}

\item{dl}{numeric, default 0.8. Step size along linear diffusion.}

\item{da}{numeric, default 30. Angular resolution for anisotropic blur.}

\item{cutoff}{numeric normalized frequency cutoff (0-0.5)}

\item{strength}{numeric attenuation factor (0-1)}

\item{epsilon}{Small numeric value to avoid division by zero (default is 1e-8).}

\item{scale}{Numeric value controlling soft threshold (default 0.05).}

\item{power}{Numeric exponent for amplifying high values (default 1.5).}

\item{amount}{numeric, default 1. Strength of sharpening.}

\item{image}{Numeric matrix representing a grayscale image.}

\item{window_size}{Odd integer specifying the size of the sliding window (default is 3).}

\item{image_matrix}{Numeric matrix representing the GPR depth-slice.}
}
\value{
Object of same class as \code{obj} with updated \code{@data}.

Object of same class as \code{obj} with updated \code{@data}.

Object of same class as \code{obj} with processed data.

Object of same class as \code{obj} with processed data.

Object of same class as \code{obj} with processed data.

Numeric matrix of the same dimensions as \code{image}, with values normalized to \link{0,1}.

Numeric matrix of same size as image_matrix, normalized to \link{0,1}.
}
\description{
Two-dimensional filters

A collection of 2-D processing methods that operate on objects inheriting
from \code{GPRvirtual} (including \code{GPR}, \code{GPRslice}, \code{GPRcube}).

Apply a 3x3 median filter to \code{obj@data}.

Wrapper around \pkg{adimpro} anisotropic smoothing (awsaniso).

Apply a 2-D Gaussian smoothing using \pkg{mmand} (or fallback to imager).

This function performs a column-wise FFT attenuation of low-frequency
components (normalized frequency cutoff controlled with \code{cutoff}).

Apply an edge-preserving anisotropic blur to the GPR data.
Uses \pkg{imager}::blur_anisotropic internally.

Applies the Canny edge detection algorithm to 2D GPR data.
Uses \pkg{imager}::cannyEdges internally.

Enhances ridges and edges using Hessian-based filtering.
Uses \pkg{imager}::imhessian.

Enhances edges by computing the Laplacian of the image.
Uses \pkg{imager}::imlap.

Sharpens the GPR data using \pkg{imager}::imsharpen.

Enhances the local contrast of a grayscale image (matrix) using a sliding window approach.
Each pixel is transformed based on the local mean and standard deviation in its neighborhood.

Applies a smooth nonlinear transformation to increase sparsity in a GPR depth-slice.
Small values near zero are compressed while peaks and valleys are amplified.
}
\details{
Each method has the form \code{filter2D<name>()} and an S4 method for the
\code{GPRvirtual} parent class that applies the operation to \code{obj@data}.
For \code{GPRcube} objects the operation is applied slice-by-slice.

The functions include classic filters (median3x3, gaussian) and wrappers for
common \pkg{imager} processing functions (isoblur, medianblur, anisotropic,
diffusion_tensors, imgradient) plus a small FFT-based low-pass
destriper.

The S4 methods implemented here rely on an internal helper
\code{.filter2D_apply(obj, FUN, ...)} that dispatches to the appropriate
behaviour depending on whether \code{obj} is a \code{GPR}, \code{GPRslice},
or \code{GPRcube}. For \code{GPRcube} each slice \code{obj@data[,,i]} is
processed independently.

Many functions rely on the \pkg{imager} package. If \pkg{imager} is not
installed the corresponding functions will throw an informative error
telling the user to install \pkg{imager}.
}
\examples{
\dontrun{
gpr2 <- filter2Dblur_anisotropic(gpr_obj, amplitude = 0.9, sigma = 1.2)
}
\dontrun{
gpr2 <- filter2DcannyEdges(gpr_obj, sigma = 1, alpha = 0.5)
}
\dontrun{
gpr2 <- filter2Dimhessian(gpr_obj, sigma = 1)
}
\dontrun{
gpr2 <- filter2Dimlap(gpr_obj)
}
\dontrun{
gpr2 <- filter2Dimsharpen(gpr_obj, amount = 1.5)
}
set.seed(1)
img <- matrix(runif(100), nrow = 10)
enhanced <- local_contrast_enhancement(img, window_size = 5)
print(enhanced)

set.seed(1)
gpr_slice <- matrix(rnorm(100, 0, 0.05), nrow = 10)
enhanced_slice <- smooth_sparse_gpr_image(gpr_slice, scale = 0.05, power = 2)
print(enhanced_slice)

}
\concept{processing}
